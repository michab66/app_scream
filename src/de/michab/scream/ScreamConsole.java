/* ***************************************************************************
 *                                                                           *
 *  This file is part of the BeanShell Java Scripting distribution.          *
 *  Documentation and updates may be found at http://www.beanshell.org/      *
 *                                                                           *
 *  Sun Public License Notice:                                               *
 *                                                                           *
 *  The contents of this file are subject to the Sun Public License Version  *
 *  1.0 (the "License"); you may not use this file except in compliance with *
 *  the License. A copy of the License is available at http://www.sun.com    *
 *                                                                           *
 *  The Original Code is BeanShell. The Initial Developer of the Original    *
 *  Code is Pat Niemeyer. Portions created by Pat Niemeyer are Copyright     *
 *  (C) 2000.  All Rights Reserved.                                          *
 *                                                                           *
 *  GNU Public License Notice:                                               *
 *                                                                           *
 *  Alternatively, the contents of this file may be used under the terms of  *
 *  the GNU Lesser General Public License (the "LGPL"), in which case the    *
 *  provisions of LGPL are applicable instead of those above. If you wish to *
 *  allow use of your version of this file only under the  terms of the LGPL *
 *  and not to allow others to use your version of this file under the SPL,  *
 *  indicate your decision by deleting the provisions above and replace      *
 *  them with the notice and other provisions required by the LGPL.  If you  *
 *  do not delete the provisions above, a recipient may use your version of  *
 *  this file under either the SPL or the LGPL.                              *
 *                                                                           *
 *  Patrick Niemeyer (pat@pat.net)                                           *
 *  Author of Learning Java, O'Reilly & Associates                           *
 *  http://www.pat.net/~pat/                                                 *
 *                                                                           *
 *****************************************************************************/

package de.michab.scream;
//package bsh.util;

import java.awt.Component;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.Reader;
import java.io.Writer;
import java.util.Vector;

import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.JMenuItem;
import javax.swing.JPopupMenu;
import javax.swing.JScrollPane;
import javax.swing.JTextPane;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import javax.swing.text.BadLocationException;
import javax.swing.text.DefaultStyledDocument;
import javax.swing.text.JTextComponent;

import org.jdesktop.smack.swing.JPopupList;


/**
        A JFC/Swing based console for the BeanShell desktop.
        This is a descendant of the old AWTConsole.

        Improvements by: Mark Donszelmann <Mark.Donszelmann@cern.ch>
                including Cut & Paste

        Improvements by: Daniel Leuck
                including Color and Image support, key press bug workaround

  Degenerated by michab.  Removed all stuff not necessary.
  TODO( michab ): The memory used by the model has to be limited, i.e. after
                  a certain number of lines we have to begin throwing out the
                  oldest -- this also includes the history.  We must not have
                  any buffers that grow uncontrolled.

  TODO(michab) We should switch to JConsole.
*/
@SuppressWarnings("serial")
public class ScreamConsole
  extends
    JScrollPane
  implements
    Runnable,
    KeyListener,
    MouseListener,
    ActionListener,
    PropertyChangeListener
{
  // TODO History prefix search.

  // Beginning with JDK 1.4.2 the results of
  //    System.err.println( "rcs text: " + _text.getText().length() );
  //    System.err.println( "rcs  doc: " + _text.getDocument().getLength() );
  // deviate, i.e. are not longer equal as on previous jDK versions.  It is
  // not clear what the reason is, but length access will in the future only
  // be done via the document.



  /**
   * An interface to be defined for name completion service providers.
   *
   * @see ScreamConsole#setNameCompletion
   */
  public static interface NameCompletion
  {
    /**
     *
     */
    public String[] completeName( String prefix );
  };



  /**
   * The currently set name completer.
   *
   * @see ScreamConsole#setNameCompletion
   */
  private NameCompletion _nameCompletion = null;



  /**
   * Set a name completion handler.
   *
   * @param A reference to a name completion handler.
   */
  public void setNameCompletion( NameCompletion nc )
  {
    _nameCompletion = nc;
  }



  /**
   * TODO needs to be localisable.
   */
  private final static String CUT = "Cut";
  private final static String COPY = "Copy";
  private final static String PASTE = "Paste";



  /**
   *
   */
  private OutputStream _outPipe;



  /**
   *
   */
  private InputStream _inPipe;



  /**
   *
   */
  private InputStream _in;



  /**
   *
   */
  private PrintStream _out;



  /**
   * Returns the console's input stream.
   *
   * @return The console's input stream.
   */
  public InputStream getInputStream()
  {
    return _in;
  }



  /**
   *
   */
  private Reader getIn()
  {
    return new InputStreamReader(_in);
  }



  /**
   * Get a reference to the output stream.
   *
   * @return A reference to the output stream.
   */
  private PrintStream getOut()
  {
    return _out;
  }



  /**
   * Get a reference to the error stream.
   *
   * @return A reference to the error stream.
   */
  public PrintStream getErr()
  {
    return _out;
  }



  /**
   *
   */
  private int _cmdStart = 0;



  /**
   *
   */
  private final Vector _history = new Vector();



  /**
   *
   */
  private String _startedLine;



  /**
   *
   */
  private int _histLine = 0;



  /**
   *
   */
  private final JPopupMenu _menu = new JPopupMenu();



  /**
   *
   */
  private JTextComponent _text;



  /**
   *
   */
  private DefaultStyledDocument _doc;



  /**
   * Creates a console.
   */
  public ScreamConsole()
  {
    // Special TextPane which catches for cut and paste, both L&F keys and
    // programmatic behaviour
    _text = new JTextPane( _doc=new DefaultStyledDocument() )
    {
      @Override
    public void cut()
      {
        if (_text.getCaretPosition() < _cmdStart)
        {
          super.copy();
        }
        else
        {
          super.cut();
        }
      }

      @Override
    public void paste()
      {
        forceCaretIntoEditArea();
        super.paste();
      }
    };

    Font font = new Font( "Monospaced", Font.PLAIN, 12 );
    _text.setText( "" );
    setFont( font );
    _text.addKeyListener( this );
    setViewportView( _text );

    // create popup menu
    _menu.add(new JMenuItem(CUT)).addActionListener(this);
    _menu.add(new JMenuItem(COPY)).addActionListener(this);
    _menu.add(new JMenuItem(PASTE)).addActionListener(this);

    _text.addMouseListener(this);

    // make sure popup menu follows Look & Feel
    UIManager.addPropertyChangeListener(this);

    _outPipe = new PipedOutputStream();
    try
    {
      _in = new PipedInputStream((PipedOutputStream)_outPipe);
    }
    catch ( IOException e )
    {
      System.err.println("Console internal error (1)..." );
    }

    PipedOutputStream pout = new PipedOutputStream();
    _out = new PrintStream( pout );
    try
    {
      _inPipe = new BlockingPipedInputStream(pout);
    }
    catch ( IOException e )
    {
      print("Console internal error: "+e);
    }

    // Start the inpipe watcher
    new Thread(
        this,
        "JConsole in-pipe watcher" ).start();
  }



  /**
   * Get a writer connected to stream input.
   */
  public Writer getWriter()
  {
    return new PrintWriter( getOut() );
  }



  /**
   * Returns a reader connected to stream input.
   */
  public Reader getReader()
  {
    return getIn();
  }



  /**
   *
   */
  @Override
public void keyPressed( KeyEvent e )
  {
    type( e );
  }



  /**
   *
   */
  @Override
public void keyTyped(KeyEvent e)
  {
    if ( e.getKeyChar() == '\b' )
      e.setKeyCode( '\b' );
    else
      return;
    type( e );
  }



  /**
   *
   */
  @Override
public void keyReleased(KeyEvent e)
  {
    type( e );
  }



  /**
   *
   */
  private synchronized void type( KeyEvent e )
  {
    // This is a workaround for a problem that has been first identified for
    // the handling of the backspace key:  For the console user it was possible
    // to backspace out of the command area.  On entering the next characters
    // an internal error in the getComd() method of the console class was
    // thrown.
    // The code in the switch below looked good, since the rules for consuming
    // VK_BACKSPACE are simply right.
    // The original implementers of this class also noticed the problem and
    // left a comment asking 'why this key is not consumed'.
    //
    // The final solution is that the code is fine but the switch is never
    // taken since the key event in question -- seemingly a KEY_TYPED for the
    // VK_BACKSPACE key -- carried a keyCode of VK_UNDEFINED!  Instead the
    // key char is '\b'.  The docs for KeyEvent.getKeyCode() explicitly note
    // 'For KEY_TYPED events the key code is VK_UNDEFINED'.
    //
    // TODO So far I have no better solution but the two lines below.
//    System.err.println( "kco: " + e.getKeyCode() + " kch: " + (int)e.getKeyChar() );
    if ( e.getKeyChar() == '\b' )
//    if ( e.getID() == KeyEvent.KEY_TYPED &&
//         e.getKeyCode() == KeyEvent.VK_UNDEFINED )
      e.setKeyCode( e.getKeyChar() );

    switch ( e.getKeyCode() )
    {
      case ( KeyEvent.VK_ENTER ):
        if (e.getID() == KeyEvent.KEY_PRESSED) {
            enter();
            resetEditArea();
            _text.setCaretPosition(_cmdStart);
        }
        e.consume();
        _text.repaint();
        break;

      case ( KeyEvent.VK_UP ):
        if (e.getID() == KeyEvent.KEY_PRESSED) {
          historyUp();
        }
        e.consume();
        break;

      case ( KeyEvent.VK_DOWN ):
        if (e.getID() == KeyEvent.KEY_PRESSED) {
          historyDown();
        }
        e.consume();
        break;

      // MB: Fixes a defect compared to the original code:  VK_DELETEs are
      // consumed only if the caret position is outside of the current command.
      // The original code didn't allow to delete the first character in a
      // command.
      case ( KeyEvent.VK_DELETE ):
        if ( _text.getCaretPosition() < _cmdStart )
          e.consume();
        break;

      case ( KeyEvent.VK_LEFT ):
      case ( KeyEvent.VK_BACK_SPACE ):
        if ( (_text.getCaretPosition() <= _cmdStart) )
// Why isn't this working? JDK1.3 ignores this consume...
          e.consume();
        break;
/*
      case ( KeyEvent.VK_RIGHT ):
        forceCaretMoveToStart();
        break;*/

      case ( KeyEvent.VK_HOME ):
        _text.setCaretPosition(_cmdStart);
        e.consume();
        break;

      case ( KeyEvent.VK_U ): // clear line
        if ( (e.getModifiers() & InputEvent.CTRL_MASK) > 0 ) {
          replaceEditArea( "" );
          _histLine = 0;
          e.consume();
        }
        break;

      case ( KeyEvent.VK_ALT ):
      case ( KeyEvent.VK_CAPS_LOCK ):
      case ( KeyEvent.VK_CONTROL ):
      case ( KeyEvent.VK_META ):
      case ( KeyEvent.VK_SHIFT ):
      case ( KeyEvent.VK_PRINTSCREEN ):
      case ( KeyEvent.VK_SCROLL_LOCK ):
      case ( KeyEvent.VK_PAUSE ):
      case ( KeyEvent.VK_INSERT ):
      case ( KeyEvent.VK_F1):
      case ( KeyEvent.VK_F2):
      case ( KeyEvent.VK_F3):
      case ( KeyEvent.VK_F4):
      case ( KeyEvent.VK_F5):
      case ( KeyEvent.VK_F6):
      case ( KeyEvent.VK_F7):
      case ( KeyEvent.VK_F8):
      case ( KeyEvent.VK_F9):
      case ( KeyEvent.VK_F10):
      case ( KeyEvent.VK_F11):
      case ( KeyEvent.VK_F12):
      case ( KeyEvent.VK_ESCAPE ):
        // only modifier pressed
        break;

      // Control-C
      case ( KeyEvent.VK_C ):
        if (_text.getSelectedText() == null) {
          if (( (e.getModifiers() & InputEvent.CTRL_MASK) > 0 )
              && (e.getID() == KeyEvent.KEY_PRESSED)) {
            append("^C");
          }
          e.consume();
        }
        break;

      case ( KeyEvent.VK_TAB ):
        if (e.getID() == KeyEvent.KEY_RELEASED)
        {
          doCommandCompletion( getEditAreaContents() );
        }
        e.consume();
        break;

      // This takes care that in case a character is entered the cursor gets
      // placed into the command area before the character is actually entered.
      default:
        if (
          (e.getModifiers() &
          (InputEvent.CTRL_MASK
          | InputEvent.ALT_MASK | InputEvent.META_MASK)) == 0 )
        {
          // plain character
          forceCaretIntoEditArea();
        }
        break;
    }
  }



  private Action _actTab = new AbstractAction()
  {
    @Override
    public void actionPerformed( ActionEvent ae )
    {
      System.err.println( "ActTab" );
      doCommandCompletion( getEditAreaContents() );
    }
  };


  /**
   * Forwards the focus to the embedded text component.
   */
  @Override
public void requestFocus()
  {
    _text.requestFocus();
  }



  /**
   * Implements the command completion logic.
   */
  private void doCommandCompletion( final String part )
  {
    if ( _nameCompletion == null )
      return;

    // Do the actual completion.
    String [] complete = _nameCompletion.completeName(part);

    // Check if we found something...
    if ( complete.length == 0 )
    {
      // ...and if not we try to beep and leave.
      java.awt.Toolkit.getDefaultToolkit().beep();
      return;
    }
    // Found one completion (possibly what we already have)
    else if ( complete.length == 1 && !complete[0].equals(part) )
    {
      appendCompletion( part, complete[ 0 ] );
    }
    else
    {
      try
      {
        JPopupList pc = new JPopupList( complete );

        pc.addActionListener( new ActionListener()
        {
          @Override
        public void actionPerformed( ActionEvent ae )
          {
            appendCompletion( part, ae.getActionCommand() );
          }
        } );
        // Compute the position to display the completion box.
        java.awt.Rectangle r = _text.modelToView( _text.getCaretPosition() );
        java.awt.Point p = this.getViewport().getViewPosition();
        r.translate( -p.x, -p.y );

        pc.show( this, r );
      }
      catch ( BadLocationException ble )
      {
      }
    }
  }



  /**
   * Creates a new edit area.
   */
  private void resetEditArea()
  {
    _cmdStart = _text.getDocument().getLength();
  }



  /**
   *
   */
  private void append(String string)
  {
    int slen = _text.getText().length();
    _text.select(slen, slen);
    _text.replaceSelection(string);
  }



  /**
   *
   */
  private void appendCompletion( String part, String completion )
  {
    int toffset = part.length() - completion.length();

    // This is needed if the completion found is longer than the whole line
    // that was used to compute this completion.
    if ( toffset < 0 )
      toffset = 0;

    while ( toffset < part.length() )
    {
      int comparisonLength = part.length() - toffset;

      if ( part.regionMatches( toffset, completion, 0, comparisonLength ) )
      {
        append( completion.substring( comparisonLength ) );
        return;
      }
      else
        toffset++;
    }
    throw new InternalError();
  }



  /**
   *
   */
  private void replaceEditArea( String s )
  {
     _text.select( _cmdStart, _text.getDocument().getLength() );
     _text.replaceSelection( s );
     _text.setCaretPosition( _text.getDocument().getLength() );
  }



  /**
   * In case the caret is to the left of the current command area moves the
   * caret to the end of the command area.  If the caret is inside the current
   * command area its position is not changed.
   */
  private void forceCaretIntoEditArea()
  {
    if (_text.getCaretPosition() < _cmdStart)
      _text.setCaretPosition( _text.getDocument().getLength() );
  }



  /**
   *
   */
  private void enter()
  {
    String s = getEditAreaContents();

    if ( s.length() == 0 ) // special hack for empty return!
      s = ";\n";
    else {
      _history.addElement( s );
      s = s +"\n";
    }

    append("\n");
    _histLine = 0;
    acceptLine( s );
    _text.repaint();
  }



  /**
   *
   */
  private String getEditAreaContents()
  {
    String s = "";
    try
    {
      s = _text.getText(_cmdStart, _text.getDocument().getLength() - _cmdStart);
    }
    catch ( BadLocationException e )
    {
      throw new InternalError( e.getMessage() );
    }
    return s;
  }



  /**
   *
   */
  private void historyUp()
  {
    if ( _history.size() == 0 )
      return;
    if ( _histLine == 0 )  // save current line
      _startedLine = getEditAreaContents();
    if ( _histLine < _history.size() ) {
      _histLine++;
      showHistoryLine();
    }
  }



  /**
   *
   */
  private void historyDown()
  {
    if ( _histLine == 0 )
      return;

    _histLine--;
    showHistoryLine();
  }



  /**
   *
   */
  private void showHistoryLine()
  {
    String showline;
    if ( _histLine == 0 )
      showline = _startedLine;
    else
      showline = (String)_history.elementAt( _history.size() - _histLine );

    replaceEditArea( showline );
    forceCaretIntoEditArea();
    _text.setCaretPosition( _text.getDocument().getLength() );
  }



  /**
   *
   */
  private void acceptLine( String line )
  {
    try
    {
      _outPipe.write( line.getBytes() );
      _outPipe.flush();
    }
    catch ( IOException e )
    {
      throw new RuntimeException("Console pipe broken...");
    }
  }



  /**
   *
   */
  public void println(String string)
  {
    print( string + "\n" );
    _text.repaint();
  }



  /**
   *
   */
  public synchronized void print(Object object)
  {
    append(String.valueOf(object));
    resetEditArea();
    _text.setCaretPosition(_cmdStart);
  }



  /**
   * Set the font on this component.
   *
   * @param font The font to set.
   */
  @Override
public void setFont( Font font )
  {
    super.setFont( font );

    if ( _text != null )
      _text.setFont( font );
  }



  /**
   * Returns the font set for this component.
   *
   * @return This component's font.
   */
  @Override
public Font getFont()
  {
    Font result;

    if ( _text == null )
      result = super.getFont();
    else
      result = _text.getFont();

    return result;
  }



  /**
   *
   */
  private void inPipeWatcher() throws IOException
  {
    byte [] ba = new byte [256]; // arbitrary blocking factor
    int read;
    while ( (read = _inPipe.read(ba)) != -1 ) {
      print( new String(ba, 0, read) );
      //text.repaint();
    }

    println("Console: Input closed...");
  }



  /**
   *
   */
  @Override
public void run()
  {
    try
    {
      inPipeWatcher();
    }
    catch ( IOException e )
    {
      System.err.println( "Console: I/O Error: "+e+"\n" );
    }
  }



  /** MouseListener Interface
   *
   */
  @Override
public void mouseClicked(MouseEvent event)
  {
  }



  /**
   *
   */
  @Override
public void mousePressed(MouseEvent event)
  {
    if (event.isPopupTrigger())
    {
      _menu.show((Component)event.getSource(), event.getX(), event.getY());
    }
  }



  /**
   *
   */
  @Override
public void mouseReleased(MouseEvent event)
  {
    if (event.isPopupTrigger()) {
      _menu.show((Component)event.getSource(), event.getX(), event.getY());
    }
    _text.repaint();
  }



  /**
   *
   */
  @Override
public void mouseEntered(MouseEvent event)
  {
  }



  /**
   *
   */
  @Override
public void mouseExited(MouseEvent event)
  {
  }



  /**
   * property change
   */
  @Override
public void propertyChange(PropertyChangeEvent event)
  {
    if (event.getPropertyName().equals("lookAndFeel")) {
      SwingUtilities.updateComponentTreeUI(_menu);
    }
  }



  /**
   * handle cut, copy and paste
   */
  @Override
public void actionPerformed(ActionEvent event)
  {
    String cmd = event.getActionCommand();
    if (cmd.equals(CUT)) {
      _text.cut();
    } else if (cmd.equals(COPY)) {
      _text.copy();
    } else if (cmd.equals(PASTE)) {
      _text.paste();
    }
  }



  /**
   * The overridden read method in this class will not throw "Broken pipe"
   * IOExceptions;  It will simply wait for new writers and data.
   * This is used by the JConsole internal read thread to allow writers
   * in different (and in particular ephemeral) threads to write to the pipe.
   * It also checks a little more frequently than the original read().
   * Warning: read() will not even error on a read to an explicitly closed
   * pipe (override closed to for that).
   */
  private static class BlockingPipedInputStream extends PipedInputStream
  {
    boolean closed;


    /**
     *
     */
    public BlockingPipedInputStream( PipedOutputStream pout )
      throws IOException
    {
      super(pout);
    }



    /**
     *
     */
    @Override
    public synchronized int read() throws IOException
    {
      if ( closed )
        throw new IOException("stream closed");

      while (super.in < 0) { // While no data */
        notifyAll(); // Notify any writers to wake up
        try {
          wait(750);
        } catch ( InterruptedException e ) {
          throw new InterruptedIOException();
        }
      }

      // This is what the superclass does.
      int ret = buffer[super.out++] & 0xFF;
      if (super.out >= buffer.length)
        super.out = 0;
      if (super.in == super.out)
        super.in = -1;  /* now empty */
      return ret;
    }



    /**
     *
     */
    @Override
    public void close() throws IOException
    {
      closed = true;
      super.close();
    }
  }
}
